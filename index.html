<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="Asciidoctor 0.1.4">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Scala&#8217;s Types of Types</title>
<link rel="stylesheet" href="stylesheets/foundation.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css">
<link rel="stylesheet" href="stylesheets/asciidoctor-pygments.css">
</head>
<body class="article toc2 toc-right">
<div id="header">
<h1>Scala&#8217;s Types of Types</h1>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#the-different-types-of-types-in-scala">1. The different types of&#8230; Types in Scala</a></li>
<li><a href="#work-in-progress">2. WORK IN PROGRESS</a></li>
<li><a href="#type-annotation">3. Type Annotation</a></li>
<li><a href="#unified-type-system-any-anyref-anyval">4. Unified Type System - Any, AnyRef, AnyVal</a></li>
<li><a href="#the-bottom-types-nothing-and-null">5. The Bottom Types - Nothing and Null</a></li>
<li><a href="#type-of-an-code-object-code">6. Type of an <code>object</code></a></li>
<li><a href="#type-variance-in-scala">7. Type Variance in Scala</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#traits-as-in-interfaces-with-implementation">7.1. Traits, as in "interfaces with implementation"</a></li>
<li><a href="#type-linearization-vs-the-diamond-problem">7.2. Type Linearization vs. The Diamond Problem</a></li>
</ul>
</li>
<li><a href="#refined-types-refinements">8. Refined Types (refinements)</a></li>
<li><a href="#type-alias">9. Type Alias</a></li>
<li><a href="#abstract-type-member">10. Abstract Type Member</a></li>
<li><a href="#self-recursive-type">11. Self-Recursive Type &#x2717;</a></li>
<li><a href="#type-constructor">12. Type Constructor</a></li>
<li><a href="#higher-order-kind">13. Higher-Order Kind</a></li>
<li><a href="#case-class">14. Case Class</a></li>
<li><a href="#value-class">15. Value Class</a></li>
<li><a href="#universal-trait">16. Universal Trait &#x2717;</a></li>
<li><a href="#self-type-annotation">17. Self Type Annotation</a></li>
<li><a href="#phantom-type">18. Phantom Type</a></li>
<li><a href="#structural-type">19. Structural Type</a></li>
<li><a href="#path-dependent-type">20. Path Dependent Type</a></li>
<li><a href="#type-projection">21. Type Projection</a></li>
<li><a href="#existential-types">22. Existential Types</a></li>
<li><a href="#type-lambda">23. Type Lambda &#x2717;</a></li>
<li><a href="#delayed-init">24. Delayed Init</a></li>
<li><a href="#dynamic-type">25. Dynamic Type</a></li>
<li>
<ul class="sectlevel2">
<li><a href="#applydynamic">25.1. applyDynamic</a></li>
<li><a href="#applydynamicnamed">25.2. applyDynamicNamed</a></li>
<li><a href="#selectdynamic">25.3. selectDynamic</a></li>
<li><a href="#updatedynamic">25.4. updateDynamic</a></li>
</ul>
</li>
<li><a href="#links-and-kudos">26. Links and Kudos</a></li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="the-different-types-of-types-in-scala"><a class="anchor" href="#the-different-types-of-types-in-scala"></a>1. The different types of&#8230; Types in Scala</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This blog post came into being after a few discussions about Types in Scala after some of JavaOne&#8217;s parties in 2013. After those discussions I figured that many questions are often repeated by different people, during their learning of Scala. I though that we didn&#8217;t have a full list of all tricks what we can to with Types in Scala, so I decided to write such a list - giving real life examples why we&#8217;d need these types.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="work-in-progress"><a class="anchor" href="#work-in-progress"></a>2. WORK IN PROGRESS</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While I&#8217;m working on this article since quite some time, there&#8217;s still MUCH to do!
For example Higher Kinds need a rewrite, there&#8217;s a lot of detail to be added in Self Type&#8217;s and lots and lots more. Check the todo file for more.</p>
</div>
<div class="paragraph">
<p>If you&#8217;d like to help, please do! I&#8217;ll welcome any pull request, or suggestion (well, I&#8217;d prefer pull requests ;-).</p>
</div>
<div class="paragraph">
<p>Also, if you see a section marked with "&#x2717;" it means that it needs re-work or that it&#8217;s not complete in some way.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-annotation"><a class="anchor" href="#type-annotation"></a>3. Type Annotation</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scala has Type Inference, which means that we can skip telling the Type of something each time in the source code,
and instead we just use `val`s or `def`s without "saying the type explicitly in the source". This being explicit about
the type of something, is called an Type Annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Thing</span>
<span class="tok-k">def</span> <span class="tok-n">getThing</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Thing</span>

<span class="tok-c1">// without Type Annotation, the type is infered to be `Thing`</span>
<span class="tok-k">val</span> <span class="tok-n">infered</span> <span class="tok-k">=</span> <span class="tok-n">getThing</span>

<span class="tok-c1">// with Type Annotation</span>
<span class="tok-k">val</span> <span class="tok-n">thing</span><span class="tok-k">:</span> <span class="tok-kt">Thing</span> <span class="tok-o">=</span> <span class="tok-n">getThing</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In these situations, leaving out the Type Annotation is OK. Although you may decide to always annotate return types of public methods (<strong>that&#8217;s very good idea!</strong>) in order to make the code more self-documenting.</p>
</div>
<div class="paragraph">
<p>In case of doubt you can refer to the below hint-questions to wether or not, include a Type Annotation.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It it a parameter? <strong>Yes</strong>, you have to.</p>
</li>
<li>
<p>Is it a public methods return value? <strong>Yes</strong>, for self-documenting code and control over exported types.</p>
</li>
<li>
<p>Do you need to return a more general interface than the inferencer would find? <strong>Yes</strong>, otherwise you&#8217;d expose your implementation details for example.</p>
</li>
<li>
<p>Else&#8230; No, don&#8217;t include a Type Annotation.</p>
</li>
<li>
<p>Related hint: Including Type Annotations speeds up compilation, also it&#8217;s generally nice to see the return type of a method.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>So we put Type Annotations after value names. Having this said, let&#8217;s jump into the next topics, where these types will become
more and more interesting.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="unified-type-system-any-anyref-anyval"><a class="anchor" href="#unified-type-system-any-anyref-anyval"></a>4. Unified Type System - Any, AnyRef, AnyVal</h2>
<div class="sectionbody">
<div class="paragraph">
<p>We refer to a Scala&#8217;s typesystem as being "unified" because there is a "Top Type", <code>Any</code>. <strong>This is different than Java</strong>, which has "special cases" in form of primitive types (<code>int</code>, <code>long</code>, <code>float</code>, <code>double</code>, <code>byte</code>, <code>char</code>, <code>short</code>, <code>boolean</code>), which do not extend Java&#8217;s "Almost-Top Type" - <code>java.lang.Object</code>.</p>
</div>
<div class="imageblock">
<div class="content">
<img src="http://www.blog.project13.pl/wp-content/uploads/2012/12/skitch-5.png" alt="Unified Type System">
</div>
</div>
<div class="paragraph">
<p>Scala takes on the idea of having one common Top Type for all Types by introducing <code>Any</code>. <code>Any</code> is a supertype of both <code>AnyRef</code> and <code>AnyVal</code>.</p>
</div>
<div class="paragraph">
<p><code>AnyRef</code> is the "object world" of Java (and the JVM), it corresponds to <code>java.lang.Object</code>, and is the supertype of all objects.</p>
</div>
<div class="paragraph">
<p><code>AnyVal</code> represents the "value world" of Java, such as <code>int</code> and it&#8217;s friends.</p>
</div>
<div class="paragraph">
<p>Thanks to this hierarchy, we&#8217;re able to define methods taking <code>Any</code> - thus being compatible with both <code>scala.Int</code> instances as well as <code>java.lang.String</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Person</span>

<span class="tok-k">val</span> <span class="tok-n">allThings</span> <span class="tok-k">=</span> <span class="tok-nc">ArrayBuffer</span><span class="tok-o">[</span><span class="tok-kt">Any</span><span class="tok-o">]()</span>

<span class="tok-k">val</span> <span class="tok-n">myInt</span> <span class="tok-k">=</span> <span class="tok-mi">42</span>             <span class="tok-c1">// Int, kept as low-level `int` during runtime</span>

<span class="tok-n">allThings</span> <span class="tok-o">+=</span> <span class="tok-n">myInt</span>         <span class="tok-c1">// Int (extends AnyVal)</span>
                           <span class="tok-c1">// has to be boxed (!) -&gt; becomes java.lang.Integer in the collection (!)</span>

<span class="tok-n">allThings</span> <span class="tok-o">+=</span> <span class="tok-k">new</span> <span class="tok-nc">Person</span><span class="tok-o">()</span>  <span class="tok-c1">// Person (extends AnyRef), no magic here</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>For the Typesystem it&#8217;s transparent, though on the JVM level once we get into <code>ArrayBuffer[Any]</code> our Int instances will have to be packed into objects. Let&#8217;s investigate the above example&#8217;s by using the Scala REPL and it&#8217;s <code>:javap</code> command (which shows the generated bytecode for our test class):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">35: invokevirtual #47  // Method myInt:()I
38: invokestatic  #53  // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
41: invokevirtual #57  // Method scala/collection/mutable/ArrayBuffer.$plus$eq:(Ljava/lang/Object;)Lscala/collection/mutable/ArrayBuffer;</code></pre>
</div>
</div>
<div class="paragraph">
<p>You&#8217;ll notive that <code>myInt</code> is still carrying the value of a <code>int primitive</code> (this is visible as <code>I</code> at the end of the <code>myInt:()I</code> <strong>invokevirtual</strong> call). Then, right before adding it to the ArrayBuffer, scalac inserted a call to <code>BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer</code> (a small hint for not frequent bytecode readers, the method it calls is: <code>public Integer boxToInteger(i: int)</code>). This way, by having a smart compiler and treating everything as an object in this common hierarchy we&#8217;re able to get away from the "but primitives are different" edge-cases, at least at the level of our Scala source code - the compiler takes care of it for us. On JVM level, the distinction is still there of course, and scalac will do it&#8217;s best to keep using primitives wherever possible, as operations on them are faster, and take less memory (objects are obviously bigger than primitives).</p>
</div>
<div class="paragraph">
<p>On the other hand, we can limit a method to only be able to work on "lightweight" Value Types:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">def</span> <span class="tok-n">check</span><span class="tok-o">(</span><span class="tok-n">in</span><span class="tok-k">:</span> <span class="tok-kt">AnyVal</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">()</span>

<span class="tok-n">check</span><span class="tok-o">(</span><span class="tok-mi">42</span><span class="tok-o">)</span>    <span class="tok-c1">// Int -&gt; AnyVal</span>
<span class="tok-n">check</span><span class="tok-o">(</span><span class="tok-mf">13.37</span><span class="tok-o">)</span> <span class="tok-c1">// Double -&gt; AnyVal</span>

<span class="tok-n">check</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">Object</span><span class="tok-o">)</span> <span class="tok-c1">// -&gt; AnyRef = fails to compile</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example I&#8217;ve used a TypeClass <code>Checker[T]</code> and a type bound, which will be discussed below. The general idea is that this method will only take value classes, be it Int or our own Value Type. While probably not used very often, it shows how nicely the typesystem embraces java primitives, and brings them into the "real" type system, and not as a separate case, as is the case with Java.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="the-bottom-types-nothing-and-null"><a class="anchor" href="#the-bottom-types-nothing-and-null"></a>5. The Bottom Types - Nothing and Null</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In Scala everything has "some" type&#8230; but have you ever wondered how the type inferencer can still work, and infer sound types when working with "weird" situations like throwing exceptions? Let&#8217;s investigate the below "if/else throw" example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">val</span> <span class="tok-n">thing</span><span class="tok-k">:</span> <span class="tok-kt">Int</span> <span class="tok-o">=</span>
  <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">test</span><span class="tok-o">)</span>
    <span class="tok-mi">42</span>                             <span class="tok-c1">// : Int</span>
  <span class="tok-k">else</span>
    <span class="tok-k">throw</span> <span class="tok-k">new</span> <span class="tok-nc">Exception</span><span class="tok-o">(</span><span class="tok-s">&quot;Whoops!&quot;</span><span class="tok-o">)</span> <span class="tok-c1">// : Nothing</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see in the comments, the type of the if block is <code>Int</code> (easy), the type of the else block is <code>Nothing</code> (interresting). The inferencer was able to infer that the <code>thing</code> value, will only ever be of type <code>Int</code>. This is because of the <strong>Bottom Type</strong> property of Nothing.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
A very nice intuition about how bottom types work is: <em>"<code>Nothing</code> extends everything."</em>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Type inference always looks for the "common type" of both branches in an if stamement, so if the other branch here is a Type that extends everything, the infered type will automatically be the Type from the first branch.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">Types</span> <span class="tok-n">visualized</span><span class="tok-k">:</span>

           <span class="tok-err">[</span><span class="tok-kt">Int</span><span class="tok-err">]</span> <span class="tok-kt">-&gt;</span> <span class="tok-kt">...</span> <span class="tok-kt">-&gt;</span> <span class="tok-kt">AnyVal</span> <span class="tok-kt">-&gt;</span> <span class="tok-kt">Anything</span>
<span class="tok-nc">Nothing</span> <span class="tok-o">-&gt;</span> <span class="tok-o">[</span><span class="tok-kt">Int</span><span class="tok-o">]</span> <span class="tok-o">-&gt;</span> <span class="tok-o">...</span> <span class="tok-o">-&gt;</span> <span class="tok-nc">AnyVal</span> <span class="tok-o">-&gt;</span> <span class="tok-nc">Any</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The same reasoning can be applied to the second Bottom Type in Scala - <code>Null</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">val</span> <span class="tok-n">thing</span><span class="tok-k">:</span> <span class="tok-kt">String</span> <span class="tok-o">=</span>
  <span class="tok-k">if</span> <span class="tok-o">(</span><span class="tok-n">test</span><span class="tok-o">)</span>
    <span class="tok-s">&quot;Yay!&quot;</span>  <span class="tok-c1">// : String</span>
  <span class="tok-k">else</span>
  	<span class="tok-kc">null</span>    <span class="tok-c1">// : Null</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The type of <code>thing</code> is as expected, String. <code>Null</code> follows ALMOST the same rules as Nothing. I&#8217;ll use this case to take a small detour to talk about inference, and the differences between AnyVals and AnyRefs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">Types visualized:

        [String] -> AnyRef -> Any
Null -> [String] -> AnyRef -> Any

infered type: String</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s think about <code>Int</code> and other primitives, which cannot hold null values. To investigate this case let&#8217;s drop into the REPL and use the <code>:type</code> command (which allows to get the type of an expression):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala-repl language-scala-repl">scala> :type if (false) 23 else null
Any</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is different than the case with a String object in one of the branches. Let&#8217;s look into the types in detail here, as <code>Null</code> is a bit less "extends everything" than <code>Nothing</code>. Let&#8217;s see what <code>Int</code> extends in detail, by using <code>:type</code> again on it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala-repl language-scala-repl">scala> :type -v 12
// Type signature
Int

// Internal Type structure
TypeRef(TypeSymbol(final abstract class Int extends AnyVal))</code></pre>
</div>
</div>
<div class="paragraph">
<p>The verbose option adds a bit more information here, now we know that <code>Int</code> is an <code>AnyVal</code> - this is a special class representing value types - which cannot hold <code>Null</code>. If we look into &lt;a href="https://github.com/scala/scala/blob/v2.10.3/src/library/scala/AnyVal.scala"&gt;AnyVal&#8217;s sources&lt;/a&gt;, we&#8217;ll find:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">abstract</span> <span class="tok-k">class</span> <span class="tok-nc">AnyVal</span> <span class="tok-k">extends</span> <span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">NotNull</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>I&#8217;m bringing this up here because the core functionality of AnyVal is so nicely represented using the Types here. <strong>Notice the <code>NotNull</code> trait!</strong></p>
</div>
<div class="paragraph">
<p>Coming back to the subject why the common Type for our if statement with an <code>AnyVal</code> on one code block and a <code>null</code> on the other one was Any and not something else. The one sentence way to define it is: <code>Null extends all AnyRefs</code> whereas <code>Nothing extends anything</code>. As AnyVals (such as numbers), are not in the same tree as AnyRefs, the only common Type between a number and a <code>null</code> value is Any - which explains our case.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">Types</span> <span class="tok-n">visualized</span><span class="tok-k">:</span>

<span class="tok-kt">Int</span>  <span class="tok-kt">-&gt;</span> <span class="tok-kt">NotNull</span> <span class="tok-kt">-&gt;</span> <span class="tok-kt">AnyVal</span> <span class="tok-kt">-&gt;</span> <span class="tok-o">[</span><span class="tok-kt">Any</span><span class="tok-o">]</span>
<span class="tok-nc">Null</span>            <span class="tok-o">-&gt;</span> <span class="tok-nc">AnyRef</span> <span class="tok-o">-&gt;</span> <span class="tok-o">[</span><span class="tok-kt">Any</span><span class="tok-o">]</span>

<span class="tok-n">infered</span> <span class="tok-n">type</span><span class="tok-k">:</span> <span class="tok-kt">Any</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-of-an-code-object-code"><a class="anchor" href="#type-of-an-code-object-code"></a>6. Type of an <code>object</code></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Scala `object`s are implemented via classes (obviously - as it&#8217;s the basic building block on the JVM),
but you&#8217;ll notice that we cannot get its type the same way as we would with an simple class&#8230;</p>
</div>
<div class="paragraph">
<p>I surprisingly often, would get the question on how to pass an object into a method. Just saying <code>obj: ExampleObj</code> won&#8217;t work
because that&#8217;s already referring to the instance, so there&#8217;s a member called <code>type</code> which should be used in such cases.</p>
</div>
<div class="paragraph">
<p>How it might look like in your code is explained by the below example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">object ExampleObj

def takeAnObject(obj: ExampleObj.type) = {}

takeAnObject(ExampleObj)</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-variance-in-scala"><a class="anchor" href="#type-variance-in-scala"></a>7. Type Variance in Scala</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Variance, in general, can be explained as "type compatible-ness" between types, forming an <code>extends</code> relation.
The most popular cases where you&#8217;ll have to deal with this is when working with containers or functions (so&#8230; surprisingly often!).</p>
</div>
<div class="paragraph">
<p>A major difference from Java in Scala is, that container types are <strong>not-variant by default</strong>!
This means that if you have a container defined as <code>Box[A]</code>, and then use it with an <code>Fruit</code> in place
of the type parameter <code>A</code>, you will not be able to insert an <code>Apple</code> (which <em>IS-A</em> <code>Fruit</code>) into it.</p>
</div>
<div class="paragraph">
<p>Variance in Scala is defined by using <code>+</code> and <code>-</code> signs in front of type parameters.</p>
</div>
<div class="paragraph">
<p><a href="http://www.slideshare.net/dgalichet/demystifying-scala-type-system">http://www.slideshare.net/dgalichet/demystifying-scala-type-system</a></p>
</div>
<table class="tableblock frame-all grid-all" style="width:100%; ">
<colgroup>
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;"> 
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Name</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Scala Syntax</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Invariant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[T'] and C[T] are <strong>not</strong> related</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[T]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Covariant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[T'] is a subclass of C[T]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[+T]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Contravariant</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[T] is a subclass of C[T']</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C[-T]</p></td>
</tr>
</tbody>
</table>

<div class="paragraph">
<p>The above table ilustrates all variance cases we&#8217;ll have to worry about - in an abstract way.
In case you&#8217;re wondering where you&#8217;d have to care about this - in fact, you&#8217;re exposed to this each time
you&#8217;re working with collections you&#8217;re being faced with the question "is it covariant?".</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
Most <em>immutable</em> collections are <em>covariant</em>, and most <em>mutable</em> collections are <em>invariant</em>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There are (at least) two nice and very intuitive examples of this in Scala. One being "any collection", where we&#8217;ll use a <code>List[+A]</code> as our example, and functions. When talking about <code>List</code> in Scala, we usualy mean <code>scala.collection.immutable.List[+A]</code>, which is immutable as well as covariant, let&#8217;s look how this relates to building lists containing items of different types.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Fruit</span>
<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Apple</span><span class="tok-o">()</span> <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span>
<span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Orange</span><span class="tok-o">()</span> <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span>

<span class="tok-k">val</span> <span class="tok-n">l1</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">Apple</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">Apple</span><span class="tok-o">()</span> <span class="tok-o">::</span> <span class="tok-nc">Nil</span>
<span class="tok-k">val</span> <span class="tok-n">l2</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">Fruit</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">Orange</span><span class="tok-o">()</span> <span class="tok-o">::</span> <span class="tok-n">l1</span>

<span class="tok-c1">// and also, it&#39;s safe to prepend with &quot;anything&quot;,</span>
<span class="tok-c1">// as we&#39;re building a new list - not modifying the previous instance</span>

<span class="tok-k">val</span> <span class="tok-n">l3</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">AnyRef</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">::</span> <span class="tok-n">l2</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>It&#8217;s worth mentioning that while <strong>having immutable collections co-variant is <em>safe</em></strong>, the same cannot be said about mutable collections. The classic example here is <code>Array[T]</code> which is <strong>invariant</strong>. Let&#8217;s look at what invariance means for us here, and how it saves us from mistakes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// won&#39;t compile</span>
<span class="tok-k">val</span> <span class="tok-n">a</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">Any</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-nc">Array</span><span class="tok-o">[</span><span class="tok-kt">Int</span><span class="tok-o">](</span><span class="tok-mi">1</span><span class="tok-o">,</span> <span class="tok-mi">2</span><span class="tok-o">,</span> <span class="tok-mi">3</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such an assigment won&#8217;t compile, because of Array&#8217;s invariance. If this assignment would be valid, we&#8217;d run into the problem of being able to write such code: <code>a(0) = "" // ArrayStoreException!</code> which would fail with the dreaded <code>ArrayStoreException</code>.</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
We said that "most" immutable collections are covariant in scala. In case you&#8217;re curious, one example of an immutable collection which stands out from that, and is invariant, it&#8217;s <code>Set[A]</code>.
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="traits-as-in-interfaces-with-implementation"><a class="anchor" href="#traits-as-in-interfaces-with-implementation"></a>7.1. Traits, as in "interfaces with implementation"</h3>
<div class="paragraph">
<p>First, let&#8217;s take a look as the simplest thing possible about traits:
how we can basically treat a type with multiple traits mixed in, as if it is implementing these "interfaces with implementation",
as you might be tempted to call them if comming from Java-land:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Base</span> <span class="tok-o">{</span> <span class="tok-k">def</span> <span class="tok-n">b</span> <span class="tok-k">=</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">}</span>
<span class="tok-k">trait</span> <span class="tok-nc">Cool</span> <span class="tok-o">{</span> <span class="tok-k">def</span> <span class="tok-n">c</span> <span class="tok-k">=</span> <span class="tok-s">&quot;&quot;</span> <span class="tok-o">}</span>
<span class="tok-k">trait</span> <span class="tok-nc">Awesome</span> <span class="tok-o">{</span> <span class="tok-k">def</span> <span class="tok-n">a</span> <span class="tok-o">=</span><span class="tok-s">&quot;&quot;</span> <span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">BA</span> <span class="tok-k">extends</span> <span class="tok-nc">Base</span> <span class="tok-k">with</span> <span class="tok-nc">Awesome</span>
<span class="tok-k">class</span> <span class="tok-nc">BC</span> <span class="tok-k">extends</span> <span class="tok-nc">Base</span> <span class="tok-k">with</span> <span class="tok-nc">Cool</span>

<span class="tok-c1">// as you might expect, you can upcast these instances into any of the traits they&#39;ve mixed-in</span>
<span class="tok-k">val</span> <span class="tok-n">ba</span><span class="tok-k">:</span> <span class="tok-kt">BA</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-nc">BA</span>
<span class="tok-k">val</span> <span class="tok-n">bc</span><span class="tok-k">:</span> <span class="tok-kt">Base</span> <span class="tok-kt">with</span> <span class="tok-kt">Cool</span> <span class="tok-o">=</span> <span class="tok-k">new</span> <span class="tok-nc">BC</span>

<span class="tok-k">val</span> <span class="tok-n">b1</span><span class="tok-k">:</span> <span class="tok-kt">Base</span> <span class="tok-o">=</span> <span class="tok-n">ba</span>
<span class="tok-k">val</span> <span class="tok-n">b2</span><span class="tok-k">:</span> <span class="tok-kt">Base</span> <span class="tok-o">=</span> <span class="tok-n">bc</span>

<span class="tok-n">ba</span><span class="tok-o">.</span><span class="tok-n">a</span>
<span class="tok-n">bc</span><span class="tok-o">.</span><span class="tok-n">c</span>
<span class="tok-n">b1</span><span class="tok-o">.</span><span class="tok-n">b</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So far this should have been relatively well known to you. Now let&#8217;s to into the world of the "diamond problem",
which people who know C++ might have been expecting. Basically "The Diamond Problem" is a situation during multiple inheritance
where we&#8217;re not sure to what we want to refer to. The below image ilustrates the problem, if you would think of traits as if they were
directly multiple inheritance:</p>
</div>
</div>
<div class="sect2">
<h3 id="type-linearization-vs-the-diamond-problem"><a class="anchor" href="#type-linearization-vs-the-diamond-problem"></a>7.2. Type Linearization vs. The Diamond Problem</h3>
<div class="paragraph">
<p>image::http://ktoso.github.io/scala-types-of-types/assets/img/220px-Diamond_inheritance.svg.png</p>
</div>
<div class="paragraph">
<p>For the "diamond problem" to appear, it&#8217;s enough if we have one overriding implementation in <code>B</code> or/and <code>C</code>. This introduces an ambiguity when calling the common method in <code>D</code>, did we inherit the version of the method from <code>C</code> or from <code>B</code>? In Scala&#8217;s case the case with only one overriding method is very simple - the override wins. But let&#8217;s work through the more complex case:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>class <code>A</code> defines a method <code>common</code> returning <code>a</code>,</p>
</li>
<li>
<p>trait <code>B</code> DOES override <code>common</code> to return <code>b</code>,</p>
</li>
<li>
<p>trait <code>C</code> DOES override <code>common</code> to return <code>c</code>,</p>
</li>
<li>
<p>class <code>D</code> extends both <code>B</code> and <code>C</code>,</p>
</li>
<li>
<p>which version of the <code>common</code> method does class <code>D</code> inherit? The overriden impementation from <code>C</code>, or theone from <code>B</code>?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>This amgiguity is a pain point of every multiple-inheritance-like mechanism. Scala solves this problem by so called <strong>Type Linearization</strong>.
In other words, given a diamond class hierarchy, we are <strong>always</strong> (and <strong>deterministically</strong>) able to determine what will be called when inside D we call <code>common</code>.
Let&#8217;s put this into code and then talk about linearization:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">A</span> <span class="tok-o">{</span> <span class="tok-k">def</span> <span class="tok-n">common</span> <span class="tok-k">=</span> <span class="tok-s">&quot;A&quot;</span> <span class="tok-o">}</span>

<span class="tok-k">trait</span> <span class="tok-nc">B</span> <span class="tok-k">extends</span> <span class="tok-n">A</span> <span class="tok-o">{</span> <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">common</span> <span class="tok-k">=</span> <span class="tok-s">&quot;B&quot;</span> <span class="tok-o">}</span>
<span class="tok-k">trait</span> <span class="tok-nc">C</span> <span class="tok-k">extends</span> <span class="tok-n">A</span> <span class="tok-o">{</span> <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">common</span> <span class="tok-k">=</span> <span class="tok-s">&quot;C&quot;</span> <span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">D1</span> <span class="tok-k">extends</span> <span class="tok-n">B</span> <span class="tok-k">with</span> <span class="tok-n">C</span>
<span class="tok-k">class</span> <span class="tok-nc">D2</span> <span class="tok-k">extends</span> <span class="tok-n">C</span> <span class="tok-k">with</span> <span class="tok-n">B</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The results will be as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-n">D1</span><span class="tok-o">).</span><span class="tok-n">common</span> <span class="tok-o">==</span> <span class="tok-s">&quot;C&quot;</span>

<span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-n">D2</span><span class="tok-o">).</span><span class="tok-n">common</span> <span class="tok-o">==</span> <span class="tok-s">&quot;B&quot;</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason for this is that Scala applied the type linearization for us here. The algorithm goes like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>start building a list of types, the first element is the type we&#8217;re linearizing right now,</p>
</li>
<li>
<p>expand each supertype recursively and put all their types into this list (it should be flat, not nested),</p>
</li>
<li>
<p>remove duplicates from the resulting list, by scanning it from the left, and removing a type that you&#8217;ve already "seen"</p>
</li>
<li>
<p>done.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s apply this algorithm on our diamond example by hand, to verify why <code>D1 extends B with C</code> (and <code>D2 extends C with B</code>) yielded the results they did:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// start with D1:</span>
<span class="tok-n">B</span> <span class="tok-k">with</span> <span class="tok-n">C</span> <span class="tok-k">with</span> <span class="tok-o">&lt;</span><span class="tok-n">D1</span><span class="tok-o">&gt;</span>

<span class="tok-c1">// expand all the types until you rach Any for all of them:</span>
<span class="tok-o">(</span><span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">AnyRef</span> <span class="tok-k">with</span> <span class="tok-n">A</span> <span class="tok-k">with</span> <span class="tok-n">B</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-o">(</span><span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">AnyRef</span> <span class="tok-k">with</span> <span class="tok-n">A</span> <span class="tok-k">with</span> <span class="tok-n">C</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-o">&lt;</span><span class="tok-n">D1</span><span class="tok-o">&gt;</span>

<span class="tok-c1">// remove duplicates by removing &quot;already seen&quot; types, when moving left-to-right:</span>
<span class="tok-o">(</span><span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">AnyRef</span> <span class="tok-k">with</span> <span class="tok-n">A</span> <span class="tok-k">with</span> <span class="tok-n">B</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-o">(</span>                            <span class="tok-n">C</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-o">&lt;</span><span class="tok-n">D1</span><span class="tok-o">&gt;</span>

<span class="tok-c1">// write the resulting type nicely:</span>
<span class="tok-nc">Any</span> <span class="tok-k">with</span> <span class="tok-nc">AnyRef</span> <span class="tok-k">with</span> <span class="tok-n">A</span> <span class="tok-k">with</span> <span class="tok-n">B</span> <span class="tok-k">with</span> <span class="tok-n">C</span> <span class="tok-k">with</span> <span class="tok-o">&lt;</span><span class="tok-n">D1</span><span class="tok-o">&gt;</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So when calling the <code>common</code> method, it&#8217;s now very simple to decide which version we want to call: we simply look at the linearized type,
and try to resolve the method by going from the right in the resulting linearized type. In the case of <code>D1</code>, the "rightmost" trait providing an implementation of <code>common</code> is <code>C</code>, so it&#8217;s overriding the implementation provided by <code>B</code>. The result of calling <code>common</code> inside <code>D1</code> would be <code>"c"</code>.</p>
</div>
<div class="paragraph">
<p>You can wrap your head around this method by trying it out on the <code>D2</code> class - it should linearize with <code>B</code> after <code>C</code>, thus yielding a <code>"b"</code> if you&#8217;d run the code.
Also it&#8217;s rather easy to resolve the simpler cases of linearization by just thinking "rightmost wins", but this is quite an simplification, which while helpful, does not give the full picture about the algorithm.</p>
</div>
<div class="paragraph">
<p>It is worth mentioning that using this technique we also know <strong>"who is my <code>super</code>?"</strong>. It&#8217;s as easy as "looking left" in the linearized type, from wherever class you want to check who your superclass is. So for example in our case (<code>D1</code>), the superclass of <code>C</code> is <code>B</code>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="refined-types-refinements"><a class="anchor" href="#refined-types-refinements"></a>8. Refined Types (refinements)</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Refinements are very easy to explain as "subclassing without naming the subclass". So in source code it would look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Entity</span>

<span class="tok-k">trait</span> <span class="tok-nc">Persister</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">doPersist</span><span class="tok-o">(</span><span class="tok-n">e</span><span class="tok-k">:</span> <span class="tok-kt">Entity</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-n">e</span><span class="tok-o">.</span><span class="tok-n">persistForReal</span><span class="tok-o">()</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

<span class="tok-c1">// our refined instance (and type):</span>
<span class="tok-k">val</span> <span class="tok-n">refinedMockPersister</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Persister</span> <span class="tok-o">{</span>
  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">doPersist</span><span class="tok-o">(</span><span class="tok-n">e</span><span class="tok-k">:</span> <span class="tok-kt">Entity</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">()</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-alias"><a class="anchor" href="#type-alias"></a>9. Type Alias</h2>
<div class="sectionbody">
<div class="paragraph">
<p>It&#8217;s not really another kind of type, but a trick we can use to make our code more readable:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">type</span> <span class="tok-kt">User</span> <span class="tok-o">=</span> <span class="tok-nc">String</span>
<span class="tok-k">type</span> <span class="tok-kt">Age</span> <span class="tok-o">=</span> <span class="tok-nc">Int</span>

<span class="tok-k">val</span> <span class="tok-n">data</span><span class="tok-k">:</span>  <span class="tok-kt">Map</span><span class="tok-o">[</span><span class="tok-kt">User</span>, <span class="tok-kt">Age</span><span class="tok-o">]</span> <span class="tok-k">=</span>  <span class="tok-nc">Map</span><span class="tok-o">.</span><span class="tok-n">empty</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this trick the Map definition now suddenly "makes sense!". If we&#8217;d just used a <code>String =&gt; Int</code> map,
we&#8217;d make the code less readable. Here we can keep using our primitives (maybe we need this for performance etc),
but <strong>name them</strong> so it makes sense for the future reader of this class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="abstract-type-member"><a class="anchor" href="#abstract-type-member"></a>10. Abstract Type Member</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Let&#8217;s now go deeper into the use cases of Type Aliases, which we call Abstract Type Members.</p>
</div>
<div class="paragraph">
<p>With Abstract Type Members we say "I expect someone to tell me about some type - I&#8217;ll refer to it by the name MyType".
It&#8217;s most basic function is allowing us to define generic classes (templates), but instead of using the <code>class Clazz[A, B]</code> syntax, we name them inside the class, like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">SimplestContainer</span> <span class="tok-o">{</span>
  <span class="tok-k">type</span> <span class="tok-kt">A</span>      <span class="tok-c1">// Abstract Type Member</span>

  <span class="tok-k">def</span> <span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">A</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Which for Java folks may seem very similar to the <code>Container&lt;A&gt;</code> syntax at first, but it&#8217;s a bit more powerful as we&#8217;ll see in the section about <strong>Path-dependent Types</strong>, as well as in the below example.</p>
</div>
<div class="paragraph">
<p>todo; Then, this is how we would implement this trait:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">IntContainer</span> <span class="tok-k">extends</span> <span class="tok-nc">SimplestContainer</span> <span class="tok-o">{</span>
  <span class="tok-k">type</span> <span class="tok-kt">A</span> <span class="tok-o">=</span> <span class="tok-nc">Int</span>

  <span class="tok-k">def</span> <span class="tok-n">value</span> <span class="tok-k">=</span> <span class="tok-mi">42</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So we "provide the type" using a Type Alias on line 2 here, and now we can implement the value method, as its type is known.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="self-recursive-type"><a class="anchor" href="#self-recursive-type"></a>11. Self-Recursive Type &#x2717;</h2>
<div class="sectionbody">
<div class="paragraph">
<p>While this not being a Scala specific type, it still sometimes raises a few eyebrows. One example many of a self-recursive type many of us are (perhaps unknowingly) familiar with, is Java&#8217;s <code>Enum&lt;E&gt;</code>, if you&#8217;re curious about it, check out the &lt;a href="http://grepcode.com/file/repository.grepcode.com/java/root/jdk/openjdk/6-b14/java/lang/Enum.java"&gt;Enum sources from Java 7&lt;/a&gt;. But now back to Scala and first let&#8217;s see what we&#8217;re actually talking about.</p>
</div>
<div class="paragraph">
<p>Imagine you have some <code>Fruit</code> trait, and both an <code>Apple</code> and an <code>Orange</code> extend it. The Fruit trait also has an "compareTo" method, and here the problem comes up: imagine you&#8217;d want to say "<em>I can&#8217;t compare oranges with apples, they&#8217;re totally different things!</em>". First let&#8217;s look at how we loose this compile-time safety with the naive implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// naive impl, Fruit is NOT self-recursively parameterised</span>

<span class="tok-k">trait</span> <span class="tok-nc">Fruit</span> <span class="tok-o">{</span>
  <span class="tok-k">final</span> <span class="tok-k">def</span> <span class="tok-n">compareTo</span><span class="tok-o">(</span><span class="tok-n">other</span><span class="tok-k">:</span> <span class="tok-kt">Fruit</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-kc">true</span> <span class="tok-c1">// impl doesn&#39;t matter in our example, we care about compile-time</span>
<span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">Apple</span>  <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span>
<span class="tok-k">class</span> <span class="tok-nc">Orange</span> <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span>

<span class="tok-k">val</span> <span class="tok-n">apple</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Apple</span><span class="tok-o">()</span>
<span class="tok-k">val</span> <span class="tok-n">orange</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Orange</span><span class="tok-o">()</span>

<span class="tok-n">apple</span> <span class="tok-n">compareTo</span> <span class="tok-n">orange</span> <span class="tok-c1">// compiles, but we want to make this NOT compile!</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So in the naive implementation, since the trait <code>Fruit</code> has no clue about the types extending it, so it&#8217;s not possible to restrict the compareTo signature to only allow "<em>the same subclass as `this`</em>" in the parameter. Let&#8217;s now rewrite this example to use an <strong>Self Recursive Type Parameter</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Fruit</span><span class="tok-o">[</span><span class="tok-kt">T</span> <span class="tok-k">&lt;:</span> <span class="tok-kt">Fruit</span><span class="tok-o">[</span><span class="tok-kt">T</span><span class="tok-o">]]</span> <span class="tok-o">{</span>
  <span class="tok-k">final</span> <span class="tok-k">def</span> <span class="tok-n">compareTo</span><span class="tok-o">(</span><span class="tok-n">other</span><span class="tok-k">:</span> <span class="tok-kt">Fruit</span><span class="tok-o">[</span><span class="tok-kt">T</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Boolean</span> <span class="tok-o">=</span> <span class="tok-kc">true</span> <span class="tok-c1">// impl doesn&#39;t matter in our example</span>
<span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">Apple</span>  <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span><span class="tok-o">[</span><span class="tok-kt">Apple</span><span class="tok-o">]</span>
<span class="tok-k">class</span> <span class="tok-nc">Orange</span> <span class="tok-k">extends</span> <span class="tok-nc">Fruit</span><span class="tok-o">[</span><span class="tok-kt">Orange</span><span class="tok-o">]</span>

<span class="tok-k">val</span> <span class="tok-n">apple</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Apple</span>
<span class="tok-k">val</span> <span class="tok-n">orange</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Orange</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice the Type Parameter in Fruit&#8217;s signature. You could read it as "I take some <code>T</code>, that <code>T</code> must be a <code>Fruit[T]</code>", and the only way to satisfy such bounds is by extending this trait as we do with <code>Apple</code> and <code>Orange</code> now. Now if we&#8217;d try comparing <code>apple</code> to <code>orange</code> we&#8217;ll get a compile time error:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="repl language-repl">scala> orange compareTo apple
<console>:13: error: type mismatch;
 found   : Apple
 required: Fruit[Orange]
              orange compareTo apple

scala> orange compareTo orange
res1: Boolean = true</code></pre>
</div>
</div>
<div class="paragraph">
<p>So now we&#8217;re sure we&#8217;ll only ever compare apples with apples, and other Fruit with the same kind (<em>sub-class</em>) of <code>Fruit</code>. There&#8217;s more to discuss here though - what about subclasses of <code>Apple</code> and <code>Orange</code>? Well, because we "filled-in" the type parameter at Apple / Orange level in the type hierarchy, we basically said "apples can only be compared to apples", which means that sub-classes of apples, can be compared with each other - Fruit&#8217;s signature of <code>compareTo</code> will still be happy, because the right hand side of our call would be some <code>Fruit[Apple]</code>&#8201;&#8212;&#8201;only a bit more concrete, for example let&#8217;s try this with a japanese apple (ja. "りんご", "ringo") and a polish apple (pl. "Jabłuszko"):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">`りんご`</span>  <span class="tok-k">extends</span> <span class="tok-nc">Apple</span>
<span class="tok-k">object</span> <span class="tok-nc">Jabłuszko</span> <span class="tok-k">extends</span> <span class="tok-nc">Apple</span>

<span class="tok-n">`りんご`</span> <span class="tok-n">compareTo</span> <span class="tok-nc">Jabłuszko</span>
<span class="tok-c1">// true</span>
</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
You could get the same type-safety using more fancy tricks, like path dependent types or implicit parameters and type classes. But the simplest thing that does-the-job here would be this.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-constructor"><a class="anchor" href="#type-constructor"></a>12. Type Constructor</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Type Constructors act pretty much like functions, but on the type level. The simplest example would be</p>
</div>
<div class="paragraph">
<p>That is, if in normal programming you can have a function that takes a value <code>a</code> and returns a value <code>b</code> based on the previous one, then in type-level programming you&#8217;d think of a <code>List[+A]</code> being a type constructor, that is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>List[+A]</code> takes a type parameter (<code>A</code>),</p>
</li>
<li>
<p>by itself it&#8217;s not a valid type, you need to fill in the <code>A</code> somehow - "<em>construct the type</em>",</p>
</li>
<li>
<p>by fillinf it in with <code>Int</code> you&#8217;d get <code>List[Int]</code> which is a concrete type.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Using this example, you can see how similar it is to normal constructors - with the only difference that here we work on types, and not instances of objects. It&#8217;s worth reminding here that in Scala it is not valid to say something is of type <code>List</code>, <strong>unlike in Java</strong> where javac would put the <code>List&lt;Object&gt;</code> for you. Scala is more strict here, and won&#8217;t allow us to use <code>just a List</code> in the place of a type, as it&#8217;s expecting a real type - not a type constructor.</p>
</div>
<div class="paragraph">
<p>Related to this subject is that with <strong>Scala 2.11.x</strong> we&#8217;re getting a new power user command in the REPL - the <code>:kind</code> command. It allows you to check if a type is higher kind or not. Let&#8217;s check it our on a simple type constructor, such as <code>List[+A]</code> first:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// Welcome to Scala version 2.11.0-M5 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0-ea).</span>
<span class="tok-c1">// Type in expressions to have them evaluated.</span>

<span class="tok-k">:</span><span class="tok-kt">kind</span> <span class="tok-kt">List</span>
<span class="tok-c1">// scala.collection.immutable.List&#39;s kind is F[+A]</span>

<span class="tok-k">:</span><span class="tok-kt">kind</span> <span class="tok-kt">-v</span> <span class="tok-kt">List</span>
<span class="tok-c1">// scala.collection.immutable.List&#39;s kind is F[+A]</span>
<span class="tok-c1">// * -(+)-&gt; *</span>
<span class="tok-c1">// This is a type constructor: a 1st-order-kinded type.</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here we see that scalac is able to tell us that <code>List</code>, in fact, is a type constructor (it&#8217;s way more talkative when used with the <code>-verbose option). Let's investigate the syntax right above this information: `* -&gt; *</code>. This syntax is widely used to represent kinds, and actually I found it quite Haskell inspired - as this is the syntax Haskell uses to print types of functions. The most intuitive way to read it out loud would be "takes one type, returns another type". You might have noticed that we&#8217;ve omitted something from Scala&#8217;s exact output, the plus sign from the relation (as in:<code>* -(+)-&gt; *</code>), this means variance bounds and you can read up in detail about variance in section (TODO LINK TO VARIANCE).</p>
</div>
<div class="paragraph">
<p>As already mentioned, <code>List[+A]</code> (or <code>Option[+A]</code>, or <code>Set[+A]</code>&#8230; or anything that has one type parameter) is the simplest case of a type constructor - these take <strong>one</strong> parameter.
We refer to them as <strong>first-order kinds</strong> (<code>* -&gt; *</code>). It&#8217;s also worth mentioning that even a <code>Pair[+A, +B]</code> (which we can represent as <code>* -&gt; * -&gt; *</code>) is still not a "higher-order kind" - it&#8217;s still <strong>first-order</strong>. In the next section we&#8217;ll dissect what exactly higher kinds give us and how to notice one.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="higher-order-kind"><a class="anchor" href="#higher-order-kind"></a>13. Higher-Order Kind</h2>
<div class="sectionbody">
<div class="paragraph">
<p>TODO nothing here yet, coming soon&#8230;</p>
</div>
<div class="paragraph">
<p><strong>Higher Kinds</strong> on the other hand, allow us to abstract over type constructors, just like type constructors allow
us to abstract over the type they.</p>
</div>
<div class="paragraph">
<p>A classic example here is a <code>Monad</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala-repl language-scala-repl">scala> import scalaz._
import scalaz._

scala> :k Monad // Finds locally imported types.
Monad's kind is (* -> *) -> *
This is a type constructor that takes type constructor(s): a higher-kinded type.</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO: <a href="http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/">http://blogs.atlassian.com/2013/09/scala-types-of-a-higher-kind/</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="case-class"><a class="anchor" href="#case-class"></a>14. Case Class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Although very simple, let&#8217;s discuss what case classes give us. Example starts with simple java-like class</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">SimpleCircle</span><span class="tok-o">(</span><span class="tok-k">val</span> <span class="tok-n">radius</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>which generates something like this on JVM :</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">scala> :javap SimpleCircle
public class SimpleCircle extends java.lang.Object{
    public double radius();
    public void radius_$eq(double);
    public JavaCircle(double);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>but if we want it to behave like <a href="http://en.wikipedia.org/wiki/Value_object">Value Object</a>
we must override <code>equal</code> and <code>hashCode</code> methods (generate it by IDE). Now, scala for the rescue.</p>
</div>
<div class="paragraph">
<p>We can add prefix <code>case</code> to class like this (class name was changed to avoid clashes)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Circle</span><span class="tok-o">(</span><span class="tok-n">radius</span><span class="tok-k">:</span> <span class="tok-kt">Double</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>and we gets class like this in runtime (not full :javap is here to achive more clear point of view)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="asciidoc language-asciidoc">scala> :javap Circle
public class CaseCircle extends java.lang.Object implements scala.Serializable{
    public double radius();
    public CaseCircle copy(double);
    public double copy$default$1();
    public int hashCode();
    public java.lang.String toString();
    public boolean equals(java.lang.Object);
    public CaseCircle(double);
}
</code></pre>
</div>
</div>
<div class="paragraph">
<p>as we can see, we have <code>equals</code>, <code>hashCode</code> and <code>toString</code> generated by compile and mark class as Serializable.</p>
</div>
<div class="paragraph">
<p>Also compile is so kind to generate copy method, it is importent becouse case classes are <strong>immutable</strong>.
We can modify it only by creation new object with updating changed value. Example should take away doubt.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span> <span class="tok-nc">Point</span><span class="tok-o">(</span><span class="tok-n">x</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">,</span> <span class="tok-n">y</span><span class="tok-k">:</span> <span class="tok-kt">Int</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">a</span> <span class="tok-k">=</span> <span class="tok-nc">Point</span><span class="tok-o">(</span><span class="tok-mi">0</span><span class="tok-o">,</span> <span class="tok-mi">0</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">b</span> <span class="tok-k">=</span> <span class="tok-n">a</span><span class="tok-o">.</span><span class="tok-n">copy</span><span class="tok-o">(</span><span class="tok-n">y</span> <span class="tok-k">=</span> <span class="tok-mi">10</span><span class="tok-o">)</span>
<span class="tok-k">val</span> <span class="tok-n">c</span> <span class="tok-k">=</span> <span class="tok-n">b</span><span class="tok-o">.</span><span class="tok-n">copy</span><span class="tok-o">(</span><span class="tok-n">x</span> <span class="tok-k">=</span> <span class="tok-mi">10</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>so point <code>b</code> have cordinates <code>(0, 10)</code>, and point <code>c</code> have <code>(10, 10)</code></p>
</div>
<div class="paragraph">
<p>More over, case class is equipted with extractor (also generate by compiler in companion object).
It can be used in pattern matching to simplified it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">Crile</span><span class="tok-o">(</span><span class="tok-mf">2.5</span><span class="tok-o">)</span> <span class="tok-k">match</span> <span class="tok-o">{</span>
  <span class="tok-k">case</span> <span class="tok-nc">Circle</span><span class="tok-o">(</span><span class="tok-n">r</span><span class="tok-o">)</span> <span class="tok-k">=&gt;</span> <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;Radius = &quot;</span> <span class="tok-o">+</span> <span class="tok-n">r</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>More about case class can be found in <a href="http://www.scala-lang.org/files/archive/nightly/pdfs/ScalaReference.pdf#subsection.5.3.2">Scala Language Specification</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="value-class"><a class="anchor" href="#value-class"></a>15. Value Class</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Value classes have been around in Scala for a long time internally, and you&#8217;ve used them already many times because all Number&#8217;s in Scala use this compiler trick to avoid boxing and unboxing numeric values from <code>int</code> to <code>scala.Int</code> etc. As a quick reminder, let&#8217;s recall that <code>Array[Int]</code> is an actual JVM <code>int[]</code> (or for bytecode happy people, it&#8217;s the JVM runtime type called: <code>[I</code>) which has tons of performance implications, but in one word&#8201;&#8212;&#8201;arrays of numbers are fast, arrays of references not as much.</p>
</div>
<div class="paragraph">
<p>Ok, since we now know the compiler has fancy tricks to avoid boxing `int`s into `Int`s when it doesn&#8217;t have to. Let&#8217;s see how this feature is exposed for us, end users since Scala 2.10.x. The feature is called "value classes", is fairly simple to apply to your existing classes.</p>
</div>
<div class="paragraph">
<p>For our example let&#8217;s implement a <code>Meter</code> which will serve as wrapper for plain <code>Int</code> and be able to convert the number of meters, into the number of type <code>Foot</code>. We need this class because no-one understands the crazy imperial units system ;-) On the downside though, why should we pay the runtime overhead of having an object around an <code>int</code> (that&#8217;s quite a few bytes (!) per instance) if for 95% of the time we&#8217;ll be using the plain meter value - because it&#8217;s a project for the european market? Value classes to the rescue!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">case</span> <span class="tok-k">class</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Small side note</strong>: We&#8217;ll be using Case (Value) Classes in all our examples here, but it&#8217;s not technically required to do so (although very convinient). All you need to do to define a Value Class is to have a class with only <strong>one public val parameter</strong>, if you don&#8217;t the compiler will complain:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="repl language-repl">scala> class A(a: Int) extends AnyVal
<console>:7: error: value class needs to have exactly one public val parameter</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="icon-tip" title="Tip"></i>
</td>
<td class="content">
We&#8217;re using a <code>case class</code> in our examples, but it&#8217;s not a requirement. All you need to satisfy in order to implement a Value Class is:
== Type Class &#x2717;
</td>
</tr>
</table>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Writes</span><span class="tok-o">[</span><span class="tok-kt">In</span>, <span class="tok-kt">Out</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">write</span><span class="tok-o">(</span><span class="tok-n">it</span><span class="tok-k">:</span> <span class="tok-kt">In</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Out</span>
<span class="tok-o">}</span>

<span class="tok-k">implicit</span> <span class="tok-k">val</span> <span class="tok-n">jsonWriter</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Writes</span><span class="tok-o">[</span><span class="tok-kt">Person</span>, <span class="tok-kt">Json</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">write</span><span class="tok-o">(</span><span class="tok-n">p</span><span class="tok-k">:</span> <span class="tok-kt">Person</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-nc">Json</span><span class="tok-o">.</span><span class="tok-n">toJson</span><span class="tok-o">(</span><span class="tok-n">p</span><span class="tok-o">)</span>
<span class="tok-o">}</span>

<span class="tok-k">implicit</span> <span class="tok-k">class</span> <span class="tok-nc">Writeable</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">write</span><span class="tok-o">[</span><span class="tok-kt">B</span><span class="tok-o">](</span><span class="tok-k">implicit</span> <span class="tok-n">writes</span><span class="tok-k">:</span> <span class="tok-kt">Writes</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">B</span><span class="tok-o">])</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="universal-trait"><a class="anchor" href="#universal-trait"></a>16. Universal Trait &#x2717;</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Universal traits are traits that <code>extend Any</code>, they should only have `def`s, and no initialization code.</p>
</div>
<div class="paragraph">
<p>TODO TODO</p>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="icon-warning" title="Warning"></i>
</td>
<td class="content">
TODO IMPLEMENT DOCS :-)
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="self-type-annotation"><a class="anchor" href="#self-type-annotation"></a>17. Self Type Annotation</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>Self Types</strong> are used in order to "require" that, if another class uses this trait,
it should also provide implementation of whatever it is that you&#8217;re requireing.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at an example where a service requires some Module which provides other services.
We can state this using the following Self Type Annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Module</span> <span class="tok-o">{</span>
  <span class="tok-k">lazy</span> <span class="tok-k">val</span> <span class="tok-n">serviceInModule</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ServiceInModule</span>
<span class="tok-o">}</span>

<span class="tok-k">trait</span> <span class="tok-nc">Service</span> <span class="tok-o">{</span>
  <span class="tok-k">this:</span> <span class="tok-kt">Module</span> <span class="tok-o">=&gt;</span>

  <span class="tok-k">def</span> <span class="tok-n">doTheThings</span><span class="tok-o">()</span> <span class="tok-k">=</span> <span class="tok-n">serviceInModule</span><span class="tok-o">.</span><span class="tok-n">doTheThings</span><span class="tok-o">()</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The second line can be read as "I&#8217;m a Module". It might seem yield the exactly same But how does this differ from extending <code>Module</code> right away?</p>
</div>
<div class="paragraph">
<p>which means that someone will have to give us this Module at instanciation time:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">TestingModule</span> <span class="tok-k">extends</span> <span class="tok-nc">Module</span> <span class="tok-o">{</span> <span class="tok-cm">/*...*/</span> <span class="tok-o">}</span>

<span class="tok-k">new</span> <span class="tok-nc">Service</span> <span class="tok-k">with</span> <span class="tok-nc">TestingModule</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you were to try to instanciate it without mixing in the required trait it would fail like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">new</span> <span class="tok-nc">Service</span>

<span class="tok-c1">// class Service cannot be instantiated because it does not conform to its self-type Service with Module</span>
<span class="tok-c1">//              new Service</span>
<span class="tok-c1">//              ^</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should also keep in mind, that it&#8217;s OK, to specify more than one trait when using the self-type syntax.
And while we&#8217;re at it, let&#8217;s discuss why it is called self-type (except for the "yeah, it makes sense" factor). Turns out a popular style (and possibility) to write it looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Service</span> <span class="tok-o">{</span>
  <span class="tok-n">self</span><span class="tok-k">:</span> <span class="tok-kt">MongoModule</span> <span class="tok-kt">with</span> <span class="tok-kt">APIModule</span> <span class="tok-o">=&gt;</span>

  <span class="tok-k">def</span> <span class="tok-n">delegated</span> <span class="tok-k">=</span> <span class="tok-n">self</span><span class="tok-o">.</span><span class="tok-n">doTheThings</span><span class="tok-o">()</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>In fact, you can use any identifier (not just <code>this</code> or <code>self</code>) and then refer to it from your class.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="phantom-type"><a class="anchor" href="#phantom-type"></a>18. Phantom Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p><strong>TODO MORE EXAMPLES HERE</strong></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">Started</span>
<span class="tok-k">trait</span> <span class="tok-nc">Stopped</span>
<span class="tok-k">trait</span> <span class="tok-nc">StartStopState</span>
<span class="tok-k">trait</span> <span class="tok-nc">Started</span> <span class="tok-k">extends</span> <span class="tok-nc">StartStopState</span>
<span class="tok-k">trait</span> <span class="tok-nc">Stopped</span> <span class="tok-k">extends</span> <span class="tok-nc">StartStopState</span>

<span class="tok-k">class</span> <span class="tok-nc">Service</span><span class="tok-o">[</span><span class="tok-kt">State</span> <span class="tok-k">&lt;:</span> <span class="tok-kt">StartStopState</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">start</span><span class="tok-o">[</span><span class="tok-kt">T</span> <span class="tok-k">&gt;:</span> <span class="tok-kt">State</span> <span class="tok-k">&lt;:</span> <span class="tok-kt">Stopped</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-k">this</span><span class="tok-o">.</span><span class="tok-n">asInstanceOf</span><span class="tok-o">[</span><span class="tok-kt">Service</span><span class="tok-o">[</span><span class="tok-kt">Started</span><span class="tok-o">]]</span>
<span class="tok-o">}</span>
<span class="tok-k">val</span> <span class="tok-n">x</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Serice</span><span class="tok-o">[</span><span class="tok-kt">Stopped</span><span class="tok-o">]()</span>
<span class="tok-k">val</span> <span class="tok-n">x</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Service</span><span class="tok-o">[</span><span class="tok-kt">Stopped</span><span class="tok-o">]()</span>
<span class="tok-n">x</span><span class="tok-o">.</span><span class="tok-n">start</span>
<span class="tok-n">res1</span><span class="tok-o">.</span><span class="tok-n">start</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now we&#8217;re starting to get into the more interesting Types! :-)</p>
</div>
<div class="paragraph">
<p>Phantom Types are a mean of staticly validating your sources, during compile time.
It&#8217;s used in many libraries, to prevent you from using some API, with an object in "not the right state".</p>
</div>
<div class="paragraph">
<p>To set the stage for our Phantom Type usage let&#8217;s first define a <code>ServiceHandle</code> class,
and <code>trait`s to represent the state it is in. We want to prevent users of our API from calling `stop()</code> on an already
<code>Stopped</code> instance, as well as prevent them from calling <code>start()</code> on an already <code>Running</code> instance.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// the traits are expected to be only used with our ServiceHandle,</span>
<span class="tok-c1">// which we nicely express using Self Type Annotations.</span>
<span class="tok-k">trait</span> <span class="tok-nc">Stopped</span> <span class="tok-o">{</span> <span class="tok-k">this:</span> <span class="tok-kt">ServiceHandle</span> <span class="tok-o">=&gt;</span> <span class="tok-o">}</span>
<span class="tok-k">trait</span> <span class="tok-nc">Running</span> <span class="tok-o">{</span> <span class="tok-k">this:</span> <span class="tok-kt">ServiceHandle</span> <span class="tok-o">=&gt;</span> <span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now that we have our Types prepared, let&#8217;s look at how the implementation will look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">ServiceHandle</span> <span class="tok-k">private</span> <span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">Id</span><span class="tok-o">)</span>
<span class="tok-k">object</span> <span class="tok-nc">ServiceHandle</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">create</span><span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-k">:</span> <span class="tok-kt">Id</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ServiceHandle</span><span class="tok-o">(</span><span class="tok-n">id</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-nc">Stopped</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, during instanciation of the class, we mix in the <code>Stopped</code> trait right away.
We&#8217;ve used this trick before in this blog post (series), but now it&#8217;s finally time to explain it in detail.</p>
</div>
<div class="paragraph">
<p>Turns out that the type of this newly created ServiceHandle is not only <code>ServiceHandle</code> but&#8230;
<code>ServiceHandle with Stopped</code>. It may seem underwhelming at first that "that&#8217;s it",
but let&#8217;s move on to the <code>start</code> and <code>stop</code> commands to see why this us so nice interesting.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">def</span> <span class="tok-n">start</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-k">:</span> <span class="tok-kt">ServiceHandle</span> <span class="tok-kt">with</span> <span class="tok-kt">Stopped</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
  <span class="tok-n">s</span><span class="tok-o">.</span><span class="tok-n">start</span><span class="tok-o">()</span>
  <span class="tok-k">new</span> <span class="tok-nc">ServiceHandle</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-nc">Running</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>And we can do the same for stopping a Service. Other useful methods would be,
<code>Id =&gt; Either[ServiceHandle with Stopped, ServiceHandle with Running]</code> which&#8217;s implementation you can easily imagine.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">def</span> <span class="tok-n">stop</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-k">:</span> <span class="tok-kt">ServiceHandle</span> <span class="tok-kt">with</span> <span class="tok-kt">Running</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
  <span class="tok-n">s</span><span class="tok-o">.</span><span class="tok-n">stop</span><span class="tok-o">()</span>
  <span class="tok-k">new</span> <span class="tok-nc">ServiceHandle</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-o">.</span><span class="tok-n">id</span><span class="tok-o">)</span> <span class="tok-k">with</span> <span class="tok-nc">Stopped</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>TODO MAKE BETTER EXAMPLES</p>
</div>
<div class="paragraph">
<p>Fun Java Fact: A similar end-result - failing during compilation - can also be done in Java, using annotation processors and Annotated types (you should check out Adam Warski&#8217;s example on this if you&#8217;re curious).</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="structural-type"><a class="anchor" href="#structural-type"></a>19. Structural Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Strucural Types are often compared to "<strong>type-safe duck typing</strong>", which is quite a good comparation if you&#8217;d want to get some intuition for it.</p>
</div>
<div class="paragraph">
<p>So far we&#8217;ve only been thinking about types in terms of "<strong>does it implement interface X?</strong>". With <strong>structural types</strong> we can go a step further and start reasoning
about the structure of a given object (hence the name). When using structure to check if something matches such type we have to change our question to: "<strong>does it have a method with this signature?</strong>".</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at a very popular use-case in action, to see why it is so powerful. Imagine that you have many classes of things that can be <strong>closed</strong>. In Java-land one would usualy implement the <code>java.io.Closeable</code> interface in order to make it possible to write some common <code>Closeables</code> utility class (in fact, <strong>Google Guava</strong> provides such an utility class). Now imagine that someone also implemented a <code>MyOwnCloseable</code> class but didn&#8217;t extend <code>java.io.Closeable</code>. Your <code>Closeables</code> library would be stuck - as due to the static typing, you would not be able to pass instances of <code>MyOwnCloseable</code> into it. Let&#8217;s solve this problem via using Structural Typing:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">type</span> <span class="tok-kt">JavaCloseable</span> <span class="tok-o">=</span> <span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">io</span><span class="tok-o">.</span><span class="tok-nc">Closeable</span>
<span class="tok-c1">// reminder, it&#39;s body is: { def close(): Unit }</span>

<span class="tok-k">class</span> <span class="tok-nc">MyOwnCloseable</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">close</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">=</span> <span class="tok-o">()</span>
<span class="tok-o">}</span>


<span class="tok-c1">// method taking a Structural Type</span>
<span class="tok-k">def</span> <span class="tok-n">closeQuietly</span><span class="tok-o">(</span><span class="tok-n">closeable</span><span class="tok-k">:</span> <span class="tok-o">{</span> <span class="tok-kt">def</span> <span class="tok-kt">close</span><span class="tok-o">()</span><span class="tok-kt">:</span> <span class="tok-kt">Unit</span> <span class="tok-o">})</span> <span class="tok-k">=</span>
  <span class="tok-k">try</span> <span class="tok-o">{</span>
    <span class="tok-n">closeable</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
  <span class="tok-o">}</span> <span class="tok-k">catch</span> <span class="tok-o">{</span>
    <span class="tok-k">case</span> <span class="tok-n">ex</span><span class="tok-k">:</span> <span class="tok-kt">Exception</span> <span class="tok-o">=&gt;</span> <span class="tok-c1">// ignore...</span>
  <span class="tok-o">}</span>


<span class="tok-c1">// takes a java.io.File (implements Closeable):</span>
<span class="tok-n">closeQuietly</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">StringReader</span><span class="tok-o">(</span><span class="tok-s">&quot;example&quot;</span><span class="tok-o">))</span>

<span class="tok-c1">// takes</span>
<span class="tok-n">closeQuietly</span><span class="tok-o">(</span><span class="tok-k">new</span> <span class="tok-nc">MyOwnCloseable</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The structural type is defined on the method&#8217;s parameter here. It basically says that the only thing we expect from the type that should be passed in here
is that it should have this method. It could have more methods - so it&#8217;s not an exact match but the minimal set of methods a type has to define in order to be valid for us.</p>
</div>
<div class="paragraph">
<p>Another fact to keep in mind when using <strong>Structural Typing is that it actually has huge (negative) runtime performance implications, as it is actually implemented
using reflection</strong>. We won&#8217;t look into the byte code for this case, but remember that it&#8217;s very easy to investitage the generated bytecode for scala (or java) classes, by using :javap in the Scala REPL, so you can check it out yourself.</p>
</div>
<div class="paragraph">
<p>Before we move over to the next subject, let&#8217;s briefly touch on a small but neat stype tip.
Imagine that your Structural Type is quite big, an example would be - a type representing something that you can open, work on, and then must close.
By using a Type Alias (described in detail in another section) with the Structural Type, we&#8217;re able to separate the type definition from the method, where we want to take in such instance:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">type</span> <span class="tok-kt">OpenerCloser</span> <span class="tok-o">=</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">open</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span>
  <span class="tok-k">def</span> <span class="tok-n">close</span><span class="tok-o">()</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span>
<span class="tok-o">}</span>

<span class="tok-k">def</span> <span class="tok-n">on</span><span class="tok-o">(</span><span class="tok-n">it</span><span class="tok-k">:</span> <span class="tok-kt">OpenerCloser</span><span class="tok-o">)(</span><span class="tok-n">fun</span><span class="tok-k">:</span> <span class="tok-kt">OpenerCloser</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Unit</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
  <span class="tok-n">it</span><span class="tok-o">.</span><span class="tok-n">open</span><span class="tok-o">()</span>
  <span class="tok-n">fun</span><span class="tok-o">(</span><span class="tok-n">it</span><span class="tok-o">)</span>
  <span class="tok-n">it</span><span class="tok-o">.</span><span class="tok-n">close</span><span class="tok-o">()</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So using this type alias, we&#8217;ve made the <code>def</code> way cleaner - so I&#8217;d highly recommend type aliasing bigger structural types. And one last warning, always check
if you really need to reach for structural typing, and cannot do it in some other way - as it has quite some negative performance impact.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="path-dependent-type"><a class="anchor" href="#path-dependent-type"></a>20. Path Dependent Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This Type allows us to type-check on a Type internal to another class. This may seem weird at first, but is very intuitive once you see it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Outer</span> <span class="tok-o">{</span>
  <span class="tok-k">class</span> <span class="tok-nc">Inner</span>
<span class="tok-o">}</span>

<span class="tok-k">val</span> <span class="tok-n">out1</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Outer</span>
<span class="tok-k">val</span> <span class="tok-n">out1in</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-n">out1</span><span class="tok-o">.</span><span class="tok-nc">Inner</span> <span class="tok-c1">// concrete instance, created from inside of Outer</span>

<span class="tok-k">val</span> <span class="tok-n">out2</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Outer</span>
<span class="tok-k">val</span> <span class="tok-n">out2in</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-n">out2</span><span class="tok-o">.</span><span class="tok-nc">Inner</span> <span class="tok-c1">// another instance of Inner, with the enclosing instance out2</span>

<span class="tok-c1">// the path dependent type. The &quot;path&quot; is &quot;inside out1&quot;.</span>
<span class="tok-k">type</span> <span class="tok-kt">PathDep1</span> <span class="tok-o">=</span> <span class="tok-n">out1</span><span class="tok-o">.</span><span class="tok-nc">Inner</span>


<span class="tok-c1">// type checks</span>

<span class="tok-k">val</span> <span class="tok-n">typeChecksOk</span><span class="tok-k">:</span> <span class="tok-kt">PathDep1</span> <span class="tok-o">=</span> <span class="tok-n">out1in</span>
<span class="tok-c1">// OK</span>

<span class="tok-k">val</span> <span class="tok-n">typeCheckFails</span><span class="tok-k">:</span> <span class="tok-kt">PathDep1</span> <span class="tok-o">=</span> <span class="tok-n">out2in</span>
<span class="tok-c1">// &lt;console&gt;:27: error: type mismatch;</span>
<span class="tok-c1">// found   : out2.Inner</span>
<span class="tok-c1">// required: PathDep1</span>
<span class="tok-c1">//    (which expands to)  out1.Inner</span>
<span class="tok-c1">//       val typeCheckFails: PathDep1 = out2in</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ey to understand here is that "each Outer class has its own Inner class", so it&#8217;s a different Type - dependent on which path we use to get there.</p>
</div>
<div class="paragraph">
<p>Using this kind of typing is useful, we&#8217;re able to enforce getting the type from inside of a concrete parameter. An example of a signature using this typing would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Parent</span> <span class="tok-o">{</span>
  <span class="tok-k">class</span> <span class="tok-nc">Child</span>
<span class="tok-o">}</span>

<span class="tok-k">class</span> <span class="tok-nc">ChildrenContainer</span><span class="tok-o">(</span><span class="tok-n">p</span><span class="tok-k">:</span> <span class="tok-kt">Parent</span><span class="tok-o">)</span> <span class="tok-o">{</span>
  <span class="tok-k">type</span> <span class="tok-kt">ChildOfThisParent</span> <span class="tok-o">=</span> <span class="tok-n">p</span><span class="tok-o">.</span><span class="tok-nc">Child</span>

  <span class="tok-k">def</span> <span class="tok-n">add</span><span class="tok-o">(</span><span class="tok-n">c</span><span class="tok-k">:</span> <span class="tok-kt">ChildOfThisParent</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-o">???</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using the path dependent type we have now encoded in the type system, the logic,
that this container should only contain children of this parent - and not "any parent".</p>
</div>
<div class="paragraph">
<p>We&#8217;ll see how to require the "child of any parent" Type using Type Projectsions in the next section.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-projection"><a class="anchor" href="#type-projection"></a>21. Type Projection</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Type Projections are similar to Path Dependent Types, in the way that they allow you to refer to a type of an inner class. In terms of syntax, you path your way into the structure of inner classes, splitting them with a <code>#</code> sign (hash sign, pound sign). Let&#8217;s start out by showing the first and main difference between these path dependent types (the "." syntax) vs. type projections (the "#" syntax):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// our example class structure</span>
<span class="tok-k">class</span> <span class="tok-nc">Outer</span> <span class="tok-o">{</span>
  <span class="tok-k">class</span> <span class="tok-nc">Inner</span>
<span class="tok-o">}</span>

<span class="tok-c1">// Type Projection (and alias) refering to Inner</span>
<span class="tok-k">type</span> <span class="tok-kt">OuterInnerProjection</span> <span class="tok-o">=</span> <span class="tok-nc">Outer</span><span class="tok-k">#</span><span class="tok-nc">Inner</span>

<span class="tok-k">val</span> <span class="tok-n">out1</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Outer</span>
<span class="tok-k">val</span> <span class="tok-n">out1in</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-n">out1</span><span class="tok-o">.</span><span class="tok-nc">Inner</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Another nice intuition about path dependent vs. projections is that Type Projections can be used for "type level programming" ;-)</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="existential-types"><a class="anchor" href="#existential-types"></a>22. Existential Types</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Existential Types are something that deeply relates to Type Erasure, which JVM languages "have to live with".</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">val</span> <span class="tok-n">thingy</span><span class="tok-k">:</span> <span class="tok-kt">Any</span> <span class="tok-o">=</span> <span class="tok-o">???</span>

<span class="tok-n">thingy</span> <span class="tok-k">match</span> <span class="tok-o">{</span>
  <span class="tok-k">case</span> <span class="tok-n">l</span><span class="tok-k">:</span> <span class="tok-kt">List</span><span class="tok-o">[</span><span class="tok-kt">a</span><span class="tok-o">]</span> <span class="tok-k">=&gt;</span>
     <span class="tok-c1">// lower case &#39;a&#39;, matches all types... what type is &#39;a&#39;?!</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>We don&#8217;t know the type of <code>a</code>, because of runtime type erasure. We know though that List is a type constructor, <code>* -&gt; *</code>, so there must have been some type, it could have used to construct a valid <code>List[T]</code>. This "some type", is the <strong>existentional type</strong>!</p>
</div>
<div class="paragraph">
<p>Scala provides a shortcut for it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">List</span><span class="tok-o">[</span><span class="tok-k">_</span><span class="tok-o">]</span>
 <span class="tok-c1">//  ^ some type, no idea which one!</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s say you&#8217;re working with some Abstract Type Member, that in our case will be some Monad.
We want to force users of our class into using only <code>Cool</code> instances within this Monad, because for example,
only for these Types our Monad has any meaning. We can do this via Type Bounds on these <strong>Existential Type T</strong>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">type</span> <span class="tok-kt">Monad</span><span class="tok-o">[</span><span class="tok-kt">T</span><span class="tok-o">]</span> <span class="tok-k">forSome</span> <span class="tok-o">{</span> <span class="tok-k">type</span> <span class="tok-kt">T</span> <span class="tok-k">&gt;:</span> <span class="tok-kt">Cool</span> <span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="http://mikeslinn.blogspot.com/2012/08/scala-existential-types.html">http://mikeslinn.blogspot.com/2012/08/scala-existential-types.html</a></p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="type-lambda"><a class="anchor" href="#type-lambda"></a>23. Type Lambda &#x2717;</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In type lambda&#8217;s we&#8217;ll be using <strong>Path Dependent</strong> as well as <strong>Structural Types</strong>, so if you skipped that sections you may want to go back to it.</p>
</div>
<div class="paragraph">
<p>Before we look at Type Lambdas, let&#8217;s take a step back and remind ourselfs a bit about functions and currying.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">EitherMonad</span><span class="tok-o">[</span><span class="tok-kt">A</span><span class="tok-o">]</span> <span class="tok-nc">extends</span> <span class="tok-nc">Monad</span><span class="tok-o">[({</span><span class="tok-k">type</span> <span class="tok-kt">λ</span><span class="tok-o">[</span><span class="tok-kt">α</span><span class="tok-o">]</span> <span class="tok-kt">=</span> <span class="tok-kt">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">α</span><span class="tok-o">]})</span><span class="tok-k">#</span><span class="tok-kt">λ</span><span class="tok-o">]</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">point</span><span class="tok-o">[</span><span class="tok-kt">B</span><span class="tok-o">](</span><span class="tok-n">b</span><span class="tok-k">:</span> <span class="tok-kt">B</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">B</span><span class="tok-o">]</span>
  <span class="tok-k">def</span> <span class="tok-n">bind</span><span class="tok-o">[</span><span class="tok-kt">B</span>, <span class="tok-kt">C</span><span class="tok-o">](</span><span class="tok-n">m</span><span class="tok-k">:</span> <span class="tok-kt">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">B</span><span class="tok-o">])(</span><span class="tok-n">f</span><span class="tok-k">:</span> <span class="tok-kt">B</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">C</span><span class="tok-o">])</span><span class="tok-k">:</span> <span class="tok-kt">Either</span><span class="tok-o">[</span><span class="tok-kt">A</span>, <span class="tok-kt">C</span><span class="tok-o">]</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="delayed-init"><a class="anchor" href="#delayed-init"></a>24. Delayed Init</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Since we started talking about the "weird" types in Scala, we can&#8217;t let this one go without a dedicated section for it. <code>DelayedInit</code> is actually a "<em>compiler trick</em>" above anything else, and not really tremendously important for the type system itself, but once you understand it, you&#8217;ll know how <code>scala.App</code> actually works, so let&#8217;s dive into our example with <code>App</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">Main</span> <span class="tok-k">extends</span> <span class="tok-nc">App</span> <span class="tok-o">{</span>
  <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;Hello world!&quot;</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>By looking at this code, and applying our basic Scala knowlage to it we might think "<em>Ok, so the <code>println</code> is actualy in the constructor of the Main class!</em>". And this would usually be true, but <strong>not in this case</strong>, since we inherited the <code>DelayedInit</code> trait - as <code>App</code> extends it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">App</span> <span class="tok-k">extends</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>
  <span class="tok-c1">// code here ...</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>And let&#8217;s take a look at the full source code of the <code>DelayedInit</code> trait right away:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">delayedInit</span><span class="tok-o">(</span><span class="tok-n">x</span><span class="tok-k">:</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Unit</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Unit</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you can see, it does not contain any implementation - all the work around it is actually performed by the compiler, which will treat treat all classes and objects inheriting <code>DelayedInit</code> in a special way (note: trait&#8217;s will <em>not</em> be rewriten like this). The special treatment goes like this:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>imagine your class/object body is a function, doing all these things that are in the class/object body,</p>
</li>
<li>
<p>the compiler creates this function for you, and will pass it into the <code>delayedInit(x: =&gt; Unit)</code> method (notice the <em>call-by-name</em> in the parameter).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s quickly give an example for this, and then we&#8217;ll re-implement what <code>App</code> does for us, but by hand (and the help of <code>delayedInit</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// we write:</span>
<span class="tok-k">object</span> <span class="tok-nc">Main</span> <span class="tok-k">extends</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>
  <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;hello!&quot;</span><span class="tok-o">)</span>
<span class="tok-o">}</span>

<span class="tok-c1">// the compiler emits:</span>
<span class="tok-k">object</span> <span class="tok-nc">Main</span> <span class="tok-k">extends</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">delayedInit</span><span class="tok-o">(</span><span class="tok-n">x</span><span class="tok-k">:</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Unit</span> <span class="tok-k">=</span> <span class="tok-o">{</span> <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;Hello!&quot;</span><span class="tok-o">)</span> <span class="tok-o">})</span> <span class="tok-k">=</span> <span class="tok-c1">// impl is left for us to fill in</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this mechanism you can run the body of your class whenever you want (&#8230; maybe never?). Since we now know how <code>delayedInit</code> works, let&#8217;s implement our own version of <code>scala.App</code> (which actually does it in exactly the same way).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">trait</span> <span class="tok-nc">SimpleApp</span> <span class="tok-k">extends</span> <span class="tok-nc">DelayedInit</span> <span class="tok-o">{</span>

  <span class="tok-k">private</span> <span class="tok-k">val</span> <span class="tok-n">initCode</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">ListBuffer</span><span class="tok-o">[()</span> <span class="tok-k">=&gt;</span> <span class="tok-kt">Unit</span><span class="tok-o">]</span>

  <span class="tok-k">override</span> <span class="tok-k">def</span> <span class="tok-n">delayedInit</span><span class="tok-o">(</span><span class="tok-n">body</span><span class="tok-k">:</span> <span class="tok-o">=&gt;</span> <span class="tok-nc">Unit</span><span class="tok-o">)</span> <span class="tok-o">{</span>
    <span class="tok-n">initCode</span> <span class="tok-o">+=</span> <span class="tok-o">(()</span> <span class="tok-k">=&gt;</span> <span class="tok-n">body</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>

  <span class="tok-k">def</span> <span class="tok-n">main</span><span class="tok-o">(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Array</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">])</span> <span class="tok-k">=</span> <span class="tok-o">{</span>
    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;Whoa, I&#39;m a SimpleApp!&quot;</span><span class="tok-o">)</span>

    <span class="tok-k">for</span> <span class="tok-o">(</span><span class="tok-n">proc</span> <span class="tok-k">&lt;-</span> <span class="tok-n">initCode</span><span class="tok-o">)</span> <span class="tok-n">proc</span><span class="tok-o">()</span>

    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;So long and thanks for all the fish!&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

                                <span class="tok-c1">// Running the bellow class would print print:</span>
<span class="tok-k">object</span> <span class="tok-nc">Test</span> <span class="tok-k">extends</span> <span class="tok-nc">SimpleApp</span> <span class="tok-o">{</span> <span class="tok-c1">//</span>
                                <span class="tok-c1">// Whoa, I&#39;m a SimpleApp!</span>
  <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-s">&quot;  Hello World!&quot;</span><span class="tok-o">)</span>     <span class="tok-c1">//   Hello World!</span>
                                <span class="tok-c1">// So long and thanks for all the fish!</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>That&#8217;s it. Since the rewriting is <em>not</em> applied to traits, the code we see in our <code>SimpleApp</code> will not be modified by extending DelayedInit, thanks to this, we can make use of the delayedInit method and accumulate any "class bodies" that we encouter (imagine we&#8217;re dealing with a deep hierarchy of classes here, then the <code>delayedInit</code> would be called multiple times), and then we simply implement the <code>main</code> method like you would in plain Java land.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dynamic-type"><a class="anchor" href="#dynamic-type"></a>25. Dynamic Type</h2>
<div class="sectionbody">
<div class="paragraph">
<p>I&#8217;ve had a hard time trying to decide if I should put this type into this vademecum of types or not. Lastly, I decided to add it, since it would make this collection of Type descriptions complete. So the question is, why did I hesistate so much?</p>
</div>
<div class="paragraph">
<p><strong>Scala allows us to have <strong>Dynamic Types</strong>, right inside of a Staticly/Strictly Typed language!</strong> Which is why I was considering to skip it, and leave a separate place for it&#8217;s description - as it&#8217;s basically "hacking around" all the descriptions you&#8217;ve seen above ;-) Let&#8217;s see it in action though, and how it fits into the Scala Type-ecosystem.</p>
</div>
<div class="paragraph">
<p>Imagine a class <code>JsonObject</code> which contains arbitrary JSON data. Let&#8217;s have methods, matching the keys of this JSON object, which would return an <code>Option[JValue]</code>, where a JValue can be another <code>JObject</code>, <code>JArray</code> or <code>JString</code> / <code>JNumber</code>. The usage would look like the example below.</p>
</div>
<div class="paragraph">
<p><strong>But before that, remember to enable this language feature in the given file (or REPL) via importing it.</strong>
There are a few features (like the experimental macros for example) that need to be explicitly imported in a file to be enabled. If you want to know more about these features, take a look at the [<code>scala.language</code>](<a href="http://www.scala-lang.org/api/current/index.html#scala.language$">http://www.scala-lang.org/api/current/index.html#scala.language$</a>) object or read the Scala Improvement Process 18 document ([SIP-18](<a href="https://docs.google.com/document/d/1nlkvpoIRkx7at1qJEZafJwthZ3GeIklTFhqmXMvTX9Q/edit)">https://docs.google.com/document/d/1nlkvpoIRkx7at1qJEZafJwthZ3GeIklTFhqmXMvTX9Q/edit)</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// remember, that we have to enable this language feature by importing it!</span>
<span class="tok-k">import</span> <span class="tok-nn">scala.language.dynamics</span>
</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// TODO: Has missing implementation</span>
<span class="tok-k">class</span> <span class="tok-nc">Json</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-o">???</span>
<span class="tok-o">}</span>

<span class="tok-k">val</span> <span class="tok-n">jsonString</span> <span class="tok-k">=</span> <span class="tok-s">&quot;&quot;&quot;</span>
<span class="tok-s">  {</span>
<span class="tok-s">    &quot;name&quot;: &quot;Konrad&quot;,</span>
<span class="tok-s">    &quot;favLangs&quot;: [&quot;Scala&quot;, &quot;Go&quot;, &quot;SML&quot;]</span>
<span class="tok-s">  }</span>
<span class="tok-s">&quot;&quot;&quot;</span>

<span class="tok-k">val</span> <span class="tok-n">json</span> <span class="tok-k">=</span> <span class="tok-k">new</span> <span class="tok-nc">Json</span><span class="tok-o">(</span><span class="tok-n">jsonString</span><span class="tok-o">)</span>

<span class="tok-k">val</span> <span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">Option</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span> <span class="tok-n">json</span><span class="tok-o">.</span><span class="tok-n">name</span>
<span class="tok-c1">// will compile (once we implement)!</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So&#8230; how do we fit this into an otherwise Statically Typed language? The answer is simple - compiler rewrites and a <strong>special marker trait</strong>: <code>scala.Dynamic</code>.</p>
</div>
<div class="paragraph">
<p>Ok, end of rant and back to the basics. So&#8230; How do we use Dynamic? In fact, it&#8217;s used by implementing a few "magic" methods:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>applyDynamic</strong></p>
</li>
<li>
<p><strong>applyDynamicNamed</strong></p>
</li>
<li>
<p><strong>selectDynamic</strong></p>
</li>
<li>
<p><strong>updateDynamic</strong></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Let&#8217;s take a look (with examples, at each of them. We&#8217;ll start with  the most "typical one", and move on to those which would allow the construct shown above (which didn&#8217;t (back then) compile) and make it work this time ;-)</p>
</div>
<div class="sect2">
<h3 id="applydynamic"><a class="anchor" href="#applydynamic"></a>25.1. applyDynamic</h3>
<div class="paragraph">
<p>Ok, our first magic method looks like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// applyDynamic example</span>
<span class="tok-k">object</span> <span class="tok-nc">OhMy</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">applyDynamic</span><span class="tok-o">(</span><span class="tok-n">methodName</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">Any*</span><span class="tok-o">)</span> <span class="tok-o">{</span>
    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-s">&quot;&quot;&quot;|  methodName: $methodName,</span>
<span class="tok-s">                |args: ${args.mkString(&quot;,&quot;)}&quot;&quot;&quot;</span><span class="tok-o">.</span><span class="tok-n">stripMargin</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

<span class="tok-nc">OhMy</span><span class="tok-o">.</span><span class="tok-n">dynamicMethod</span><span class="tok-o">(</span><span class="tok-s">&quot;with&quot;</span><span class="tok-o">,</span> <span class="tok-s">&quot;some&quot;</span><span class="tok-o">,</span> <span class="tok-mi">1337</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So the signature of <strong>applyDynamic</strong> takes the method name and it&#8217;s arguments. So obviously we&#8217;d have to access them by their order. Very nice for building up some strings etc. Our implementation will only print what we want to know about the method being called. Did it really get the values/method name we would exect? The output would be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-n">methodName</span><span class="tok-k">:</span> <span class="tok-kt">dynamicMethod</span><span class="tok-o">,</span>
  <span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-kt">with</span><span class="tok-o">,</span><span class="tok-n">some</span><span class="tok-o">,</span><span class="tok-mi">1337</span>
</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="applydynamicnamed"><a class="anchor" href="#applydynamicnamed"></a>25.2. applyDynamicNamed</h3>
<div class="paragraph">
<p>Ok, that was easy. But it didn&#8217;t give us too much control over the names of the parameters.
Wouldn&#8217;t it be nice if we could just write <code>JSON.node(nickname = "ktoso")</code>? Well&#8230; turns out we can!</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-c1">// applyDynamicNamed example</span>
<span class="tok-k">object</span> <span class="tok-nc">JSON</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">applyDynamicNamed</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)(</span><span class="tok-n">args</span><span class="tok-k">:</span> <span class="tok-o">(</span><span class="tok-kt">String</span><span class="tok-o">,</span> <span class="tok-kt">Any</span><span class="tok-o">)*)</span> <span class="tok-o">{</span>
    <span class="tok-n">println</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-s">&quot;&quot;&quot;Creating a $name, for:\n &quot;${args.head._1}&quot;: &quot;${args.head._2}&quot; &quot;&quot;&quot;</span><span class="tok-o">)</span>
  <span class="tok-o">}</span>
<span class="tok-o">}</span>

<span class="tok-nc">JSON</span><span class="tok-o">.</span><span class="tok-n">node</span><span class="tok-o">(</span><span class="tok-n">nickname</span> <span class="tok-k">=</span> <span class="tok-s">&quot;ktoso&quot;</span><span class="tok-o">)</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>So this time instead of just a list of values, we also get their names. Thanks to this the response for this example will be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">Creating</span> <span class="tok-n">a</span> <span class="tok-n">node</span><span class="tok-o">,</span> <span class="tok-k">for:</span>
<span class="tok-err">&quot;</span><span class="tok-kt">nickname</span><span class="tok-err">&quot;</span><span class="tok-kt">:</span> <span class="tok-err">&quot;</span><span class="tok-kt">ktoso</span><span class="tok-err">&quot;</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>I can easily imagine some pretty slick &lt;strong&gt;DLSs&lt;/strong&gt; being built around this!</p>
</div>
</div>
<div class="sect2">
<h3 id="selectdynamic"><a class="anchor" href="#selectdynamic"></a>25.3. selectDynamic</h3>
<div class="paragraph">
<p>Not it&#8217;s time for the more "unusual" methods. apply methods we&#8217;re pretty easy to understand. It&#8217;s just a method with some arbitrary name. But hey, isn&#8217;t almost everything in scala a method - or we can have a method on an object that would act as a field? Yeah, so let&#8217;s give it a try! &lt;strong&gt;We&#8217;ll use the example with applyDynamic here, and try to act like it has a method without ()&lt;/strong&gt;:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-nc">OhMy</span><span class="tok-o">.</span><span class="tok-n">name</span> <span class="tok-c1">// compilation error</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Hey! Why didn&#8217;t this work with &lt;strong&gt;applyDynamic&lt;/strong&gt;? Yeah, you figured it out already I guess. Such methods (without <code>()</code>) are treated <strong>special</strong>, as they would usualy represent fields for example. <code>applyDynamic</code> won&#8217;t trigger on such calls.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s look at our first <code>selectDynamic</code> call:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">class</span> <span class="tok-nc">Json</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-k">def</span> <span class="tok-n">selectDynamic</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span><span class="tok-k">:</span> <span class="tok-kt">Option</span><span class="tok-o">[</span><span class="tok-kt">String</span><span class="tok-o">]</span> <span class="tok-k">=</span>
    <span class="tok-n">parse</span><span class="tok-o">(</span><span class="tok-n">s</span><span class="tok-o">).</span><span class="tok-n">get</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>And this time when we execute <code>HasStuff.bananas</code> we&#8217;ll get "I have bananas!" as expected. Notice that here we return a value instead of printing it. It&#8217;s because it "acts as a field" this time around. But we could also return things (of arbitrary types) from any other method described here (&lt;strong&gt;applyDynamic&lt;/strong&gt; &lt;strong&gt;could return the string instead of printing it&lt;/strong&gt;).</p>
</div>
</div>
<div class="sect2">
<h3 id="updatedynamic"><a class="anchor" href="#updatedynamic"></a>25.4. updateDynamic</h3>
<div class="paragraph">
<p>What&#8217;s left you ask? Ask yourself the following question then: "Since I can act like a <code>Dynamic</code> object has some value in some field&#8230; What else should I be able to do with it?" My answer to that would be: "set it"! That&#8217;s what <code>updateDynamic</code> is used for. There is one special rule about <code>updateDynamic</code> though - it&#8217;s only valid if you also took care about selectDynamic - that&#8217;s why in the first example the code generated errors about both - select and update. For example if we&#8217;d implement only updateDynamic, we would get an error that selectDynamic was not implemented and it wouldn&#8217;t compile anyway. It makes sense in terms of plain semantics if you think about it.</p>
</div>
<div class="paragraph">
<p>When we&#8217;re done with this example, we can actually make the (wrong) code from the first code snippet work. The below snippet will be an implementation of what was shown on the first snippet on that other website, and this time it&#8217;ll actually work ;-)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-k">object</span> <span class="tok-nc">MagicBox</span> <span class="tok-k">extends</span> <span class="tok-nc">Dynamic</span> <span class="tok-o">{</span>
  <span class="tok-k">private</span> <span class="tok-k">var</span> <span class="tok-n">box</span> <span class="tok-k">=</span> <span class="tok-n">mutable</span><span class="tok-o">.</span><span class="tok-nc">Map</span><span class="tok-o">[</span><span class="tok-kt">String</span>, <span class="tok-kt">Any</span><span class="tok-o">]()</span>

  <span class="tok-k">def</span> <span class="tok-n">updateDynamic</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)(</span><span class="tok-n">value</span><span class="tok-k">:</span> <span class="tok-kt">Any</span><span class="tok-o">)</span> <span class="tok-o">{</span> <span class="tok-n">box</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-n">value</span> <span class="tok-o">}</span>
  <span class="tok-k">def</span> <span class="tok-n">selectDynamic</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-k">:</span> <span class="tok-kt">String</span><span class="tok-o">)</span> <span class="tok-k">=</span> <span class="tok-n">box</span><span class="tok-o">(</span><span class="tok-n">name</span><span class="tok-o">)</span>
<span class="tok-o">}</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>Using this &lt;strong&gt;Dynamic&lt;/strong&gt; "&lt;strong&gt;MagicBox&lt;/strong&gt;" we can store items at arbitrary "fields" (well, they do seem like fields, even though they are not ;-)). An example run might look like:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="pygments highlight"><code class="scala language-scala"><span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-nc">MagicBox</span><span class="tok-o">.</span><span class="tok-n">banana</span> <span class="tok-k">=</span> <span class="tok-s">&quot;banana&quot;</span>
<span class="tok-nc">MagicBox</span><span class="tok-o">.</span><span class="tok-n">banana</span><span class="tok-k">:</span> <span class="tok-kt">Any</span> <span class="tok-o">=</span> <span class="tok-n">banana</span>

<span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-nc">MagicBox</span><span class="tok-o">.</span><span class="tok-n">banana</span>
<span class="tok-n">res7</span><span class="tok-k">:</span> <span class="tok-kt">Any</span> <span class="tok-o">=</span> <span class="tok-n">banana</span>

<span class="tok-n">scala</span><span class="tok-o">&gt;</span> <span class="tok-nc">MagicBox</span><span class="tok-o">.</span><span class="tok-n">unknown</span>
<span class="tok-n">java</span><span class="tok-o">.</span><span class="tok-n">util</span><span class="tok-o">.</span><span class="tok-nc">NoSuchElementException</span><span class="tok-k">:</span> <span class="tok-kt">key</span> <span class="tok-kt">not</span> <span class="tok-kt">found:</span> <span class="tok-kt">unknown</span>
</code></pre>
</div>
</div>
<div class="paragraph">
<p>By the way&#8230; are you curious how Dynamic &lt;a href="https://github.com/scala/scala/blob/master/src/library/scala/Dynamic.scala"&gt;[source code]&lt;/a&gt; is implemented? The fun part here is that the trait Dynamic, does absolutely nothing by itself - it&#8217;s "empty", just a marker interface. Obviously all the heavylifting (<strong>call-site-rewriting</strong>) is done by the compiler here.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="links-and-kudos"><a class="anchor" href="#links-and-kudos"></a>26. Links and Kudos</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Obvisouly this vademecum required quite a bit of reseach and double-checking, so here are all the links I&#8217;ve found helpful (and you might too).</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Twitter&#8217;s Scala School: <a href="http://twitter.github.io/scala_school">http://twitter.github.io/scala_school</a> quite a bit of Scala concepts. Which helped me a lot in nicely explaining Variance (nicest explanation I found, since "ever").</p>
</li>
<li>
<p>Very old, but still valid explanation of Universal Types: <a href="http://www.scala-lang.org/old/node/128">http://www.scala-lang.org/old/node/128</a></p>
</li>
<li>
<p>Existential Types by D.R. MacIver: <a href="http://www.drmaciver.com/2008/03/existential-types-in-scala/">http://www.drmaciver.com/2008/03/existential-types-in-scala/</a></p>
</li>
<li>
<p>Scala Doc: <a href="http://www.scala-lang.org/api/current/index.html">http://www.scala-lang.org/api/current/index.html</a></p>
</li>
<li>
<p><a href="http://en.wikipedia.org/wiki/Diamond_problem#The_diamond_problem">Wikipedia on the Diamond Problem</a></p>
</li>
<li>
<p><a href="http://blog.jooq.org/2013/06/28/the-dangers-of-correlating-subtype-polymorphism-with-generic-polymorphism/">The dangers of correlating subtype polymorphism with generic polymorphism</a> blog post</p>
</li>
<li>
<p>Safari Books online about Type Linearization: <a href="http://blog.safaribooksonline.com/2013/05/30/traits-how-scala-tames-multiple-inheritance/">http://blog.safaribooksonline.com/2013/05/30/traits-how-scala-tames-multiple-inheritance/</a></p>
</li>
<li>
<p>One of the first blogs about Phantom Types in Scala: <a href="http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html">http://blog.rafaelferreira.net/2008/07/type-safe-builder-pattern-in-scala.html</a></p>
</li>
<li>
<p>Rogue (where I occasionally PullRequest too) is a great example of using Phantom Types: <a href="http://engineering.foursquare.com/2011/01/31/going-rogue-part-2-phantom-types/">http://engineering.foursquare.com/2011/01/31/going-rogue-part-2-phantom-types/</a></p>
</li>
<li>
<p>Great StackOverflow answer by <strong>Kriss Nuttycombe</strong> about Type Lambdas: <a href="http://stackoverflow.com/questions/8736164/what-are-type-lambdas-in-scala-and-what-are-their-benefits">http://stackoverflow.com/questions/8736164/what-are-type-lambdas-in-scala-and-what-are-their-benefits</a></p>
</li>
<li>
<p>The :kind pull request to <code>scala</code>, by Adriaan Moors <a href="https://github.com/scala/scala/pull/2340">https://github.com/scala/scala/pull/2340</a>
I would especialy like to thank all proof-readers and reviewers tha that have helped me with polishing this article and giving valuable feedback many many times (in chronological order :-)):</p>
</li>
<li>
<p>Sergio Rodrigez, for the most in depth article review I&#8217;ve ever seen in my life and lots of suggestions,</p>
</li>
<li>
<p>Andrzej Grzesik, fellow PolishJUG / GeeCON guy</p>
</li>
<li>
<p>Joshua Sureth, for the awesome comments and examples over lunch after devoxx</p>
</li>
<li>
<p>The awesome guys from Softwaremill</p>
</li>
<li>
<p>The awesome guys from VirtusLab</p>
</li>
<li>
<p>TODO TODO</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Give back some kudos! Share this page if you liked it using IRC, or social networks :-)</p>
</div>
<!-- Place this tag where you want the +1 button to render. -->
<div class="g-plusone"></div>

<!-- Place this tag after the last +1 button tag. -->
<script type="text/javascript">
  (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/platform.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
  })();
</script>
<a href="https://twitter.com/share" class="twitter-share-button" data-via="twitterapi" data-lang="en">Tweet</a>
<script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src="https://platform.twitter.com/widgets.js";fjs.parentNode.insertBefore(js,fjs);}}(document,"script","twitter-wjs");</script>
<script type="text/javascript" src="http://www.reddit.com/static/button/button1.js"></script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-2771927-19', 'ktoso.github.io');
  ga('send', 'pageview');

</script>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script src="http://ktoso.github.io/scala-types-of-types/assets/js/bootstrap.min.js"></script>
<script>
  $('body').scrollspy({ target: '#toc' })
</script>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2013-12-21 16:33:15 CET
</div>
</div>
</body>
</html>